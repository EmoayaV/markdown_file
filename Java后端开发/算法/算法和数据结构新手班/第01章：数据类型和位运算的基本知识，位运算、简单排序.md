# 第01章：数据类型和位运算的基本知识，位运算、简单排序

***

## 一、数据类型基本知识

### 1.数据类型分类

![image-20230621113506751](D:\markdown file\截图\image-20230621113506751.png)

### 2.基本数据类型所占字节数

| 数据类型 | 字节                  | 默认值   |
| -------- | --------------------- | -------- |
| byte     | 1-->8                 | 0        |
| short    | 2-->16                | 0        |
| int      | 4-->32                | 0        |
| long     | 8-->64                | 0        |
| float    | 4-->32                | 0.0f     |
| double   | 8-->64                | 0.0d     |
| char     | 2-->16                | ‘\u0000’ |
| boolean  | 4（根据编译环境而定） | false    |

### 3.如何将int数据以32位二进制的方式表示

![image-20230621113645828](D:\markdown file\截图\image-20230621113645828.png)

### 4.有符号整型

#### 4.1 有符号整型的表数范围

-2^31^  ----  2^31^-1

#### 4.2 反码和补码

二进制如何表示整数？

- **计算机数据的存储使用二进制`补码`形式存储**，并且`最高位是符号位`。**所以看到一个二进制比如10111011，就不用问他是补码还是源码了，都是补码**。正数的三码合一，所以直接算就行，但是负数都是补码，拿到负数的补码就必须-1取反才知道是多少。
  - 正数：`最高位是0`
  - 负数：`最高位是1`


- 规定
  - 正数的补码与反码、原码一样，称为`三码合一`
  - 负数的补码与反码、原码不一样：
    - 负数的`原码`：把十进制转为二进制，然后最高位设置为1
    - 负数的`反码`：在原码的基础上，最高位不变，其余位取反（0变1,1变0）
    - 负数的`补码`：反码+1

#### 4.3 为什么负数要补码+1？？

补码的作用
将计算机中的减法计算变成了加法计算，不用计算机中设计减法器，用硬件电路同时实现加法器和减法器较复杂。

只要一种加法电路就可以处理各种有符号数加法，而且减法可以用一个数加上另一个数的补数来表示，因此只要有加法电路及补数电路即可完成各种有符号数的加法及减法，电路设计上相当方便。

#### 4.4 正数的相反数如何表达？

<img src="D:\markdown file\截图\image-20230621124244915.png" alt="image-20230621124244915" style="zoom: 25%;" />

正数相反数=正数补码取反+1

负数相反数=负数补码取反+1

a = ~a + 1

注意：

- 这里的取反是包括符号位的，取反不等于反码，得到反码的取反不包括符号位
- 最小负数(100....0000)的相反数是他自己(100....0000)
- 0(000....0000)的相反数是他自己(000....0000)

## 二、位运算

### 1.基本语法

<img src="D:\markdown file\截图\image-20220313174721111.png" alt="image-20220313174721111" style="zoom:75%;" />

<img src="D:\markdown file\截图\image-20220312002506339.png" alt="image-20220312002506339" style="zoom:67%;" />

- 位运算符的运算过程都是基于二进制的补码运算

**（1）左移：<<**

运算规则：在一定范围内，数据每向左移动一位，相当于原数据*2。（正数、负数都适用）

【注意】当左移的位数n超过该数据类型的总位数时，相当于左移（n-总位数）位

```java
3<<4  类似于  3*2的4次幂 => 3*16 => 48
```

![image-20200225113651675](D:\markdown file\截图\image-20200225113651675.png)

```java
-3<<4  类似于  -3*2的4次幂 => -3*16 => -48
```

![image-20200225114707524](D:\markdown file\截图\image-20200225114707524.png)

**（2）右移：>>**

运算规则：在一定范围内，数据每向右移动一位，相当于原数据/2。（正数、负数都适用）

【注意】如果不能整除，`向下取整`。

```java
69>>4  类似于  69/2的4次 = 69/16 =4
```

![image-20200225115636844](D:\markdown file\截图\image-20200225115636844.png)

```
-69>>4  类似于  -69/2的4次 = -69/16 = -5
```

![image-20200225120112188](D:\markdown file\截图\image-20200225120112188.png)

**（3）无符号右移：>>>**

运算规则：往右移动后，左边空出来的位直接补0。（正数、负数都适用）

```
69>>>4  类似于  69/2的4次 = 69/16 =4
```

![image-20200225121104734](D:\markdown file\截图\image-20200225121104734.png)

```
-69>>>4   结果：268435451
```

![image-20200225121244290](D:\markdown file\截图\image-20200225121244290.png)

**（4）按位与：&**

运算规则：对应位都是1才为1，否则为0。

- 1 & 1 结果为1

- 1 & 0 结果为0

- 0 & 1 结果为0


- 0 & 0 结果为0


```java
9 & 7 = 1
```

![image-20200225122440953](D:\markdown file\截图\image-20200225122440953.png)

```java
-9 & 7 = 7
```

![image-20200225122221616](D:\markdown file\截图\image-20200225122221616.png)

**（5）按位或：|**

运算规则：对应位只要有1即为1，否则为0。

- 1 | 1 结果为1

- 1 | 0 结果为1

- 0 | 1 结果为1

- 0 & 0 结果为0


```java
9 | 7  //结果： 15
```

![image-20200225122758851](D:\markdown file\截图\image-20200225122758851.png)

```java
-9 | 7 //结果： -9
```

![image-20200225123409130](D:\markdown file\截图\image-20200225123409130.png)

**（6）按位异或：^**

运算规则：对应位一个为1一个为0，才为1，否则为0。

- 1 ^ 1 结果为0

- 1 ^ 0 结果为1

- 0 ^ 1 结果为1


- 0 ^ 0 结果为0


```java
9 ^ 7  //结果为14
```

![image-20200225123445305](D:\markdown file\截图\image-20200225123445305.png)

```java
-9 ^ 7 //结果为-16
```

![image-20200225133145727](D:\markdown file\截图\image-20200225133145727.png)

**（7）按位取反：~**

运算规则：对应位为1，则结果为0；对应位为0，则结果为1。

- ~0就是1  

- ~1就是0

```java
~9  //结果：-10
```

![image-20200225124112662](D:\markdown file\截图\image-20200225124112662.png)

```java
~-9  //结果：8
```

![image-20200225124156862](D:\markdown file\截图\image-20200225124156862.png)

### 2.举例

**举例1：**

<img src="D:\markdown file\截图\snipaste_20220312_002549.jpg" alt="snipaste_20220312_002549" style="zoom: 67%;" />

**举例2：体会 m = k ^ n = (m ^ n) ^ n**

<img src="D:\markdown file\截图\image-20220312002736157.png" alt="image-20220312002736157" style="zoom:67%;" />

### 3.案例

**案例1：**高效的方式计算2 * 8的值（经典面试题）

```
答案：2 << 3 、  8  << 1
```

**案例2：**如何交换两个int型变量的值？String呢？

```java
/**
 * @author 尚硅谷-宋红康
 * @create 16:58
 */
public class BitExer {
    public static void main(String[] args) {
        int m = 10;
		int n = 5;

		System.out.println("m = " + m + ", n = " + n);

		//（推荐）实现方式1：优点：容易理解，适用于不同数据类型    缺点：需要额外定义变量
		//int temp = m;
		//m = n;
		//n = temp;

		//实现方式2：优点：没有额外定义变量    缺点：可能超出int的范围；只能适用于数值类型
		//m = m + n; //15 = 10 + 5
		//n = m - n;//10 = 15 - 5
		//m = m - n;//5 = 15 - 10
	
		//实现方式3：优点：没有额外定义变量    缺点：不易理解；只能适用于数值类型
		m = m ^ n; 
		n = m ^ n; //(m ^ n) ^ n
		m = m ^ n;

		System.out.println("m = " + m + ", n = " + n);
    }
}
```

## 三、排序算法

### 1. 选择排序（Selection Sort）

原文地址：[点击这里](https://zhuanlan.zhihu.com/p/122293204)

**选择排序(Selection sort)**是一种简单直观的排序算法。

#### 1.1 基本思想

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面，或者将最大值放在最后面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择，每一趟从前往后查找出无序区最小值，将最小值交换至无序区最前面的位置。

#### 1.2 实现逻辑

> ① 第一轮从下标为 1 到下标为 n-1 的元素中选取最小值，若小于第一个数，则交换
> ② 第二轮从下标为 2 到下标为 n-1 的元素中选取最小值，若小于第二个数，则交换
> ③ 依次类推下去……

#### 1.3 动图演示

![v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b](D:\markdown file\截图\v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.gif)

**注**：*红色表示当前最小值，黄色表示已排序序列，绿色表示当前位置。*

具体的我们以一组无序数列｛20，40，30，10，60，50｝为例分解说明，如下图所示：

![img](https://pic4.zhimg.com/v2-23667fac97d8ee2d6d256b8302c38eaf_r.jpg)

#### 1.4 复杂度分析

> 平均时间复杂度：O(N^2)
> 最佳时间复杂度：O(N^2)
> 最差时间复杂度：O(N^2)
> 空间复杂度：O(1)
> 排序方式：In-place
> 稳定性：不稳定

选择排序的交换操作介于和(n-1)次之间。选择排序的比较操作为n(n-1)/2次之间。选择排序的赋值操作介于0和3(n-1)次之间。

比较次数O(n^2)，比较次数与关键字的初始状态无关，总的比较次数N = (n-1) + (n-2) +…+ 1 = n x (n-1)/2。交换次数O(n)，最好情况是，已经有序，交换0次；最坏情况是，逆序，交换n-1次。

#### 1.5 代码实现

```java
// 选择排序（Java）
public static void selection_sort(int[] arr) {
    int i, j, min, temp, len = arr.length;
    for (i = 0; i < len - 1; i++) {
        min = i;
        for (j = i + 1; j < len; j++)
            if (arr[min] > arr[j])
                min = j;
        temp = arr[min];
        arr[min] = arr[i];
        arr[i] = temp;
    }
}
```

```java
// 选择排序（Java）
public static void selectionSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    // 0 ~ N-1  找到最小值，在哪，放到0位置上
    // 1 ~ n-1  找到最小值，在哪，放到1 位置上
    // 2 ~ n-1  找到最小值，在哪，放到2 位置上
    for (int i = 0; i < arr.length - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < arr.length; j++) { // i ~ N-1 上找最小值的下标 
            minIndex = arr[j] < arr[minIndex] ? j : minIndex;
        }
        swap(arr, i, minIndex);
    }
}
public static void swap(int[] arr, int i, int j) {
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}
```

### 2. 冒泡排序（Bubble Sort）

#### 2.1 基本思想

冒泡排序是一种交换排序，核心是冒泡，把数组中最小的那个往上冒，冒的过程就是和他相邻的元素交换。

重复走访要排序的数列，通过两两比较相邻记录的排序码。排序过程中每次从后往前冒一个最小值，且每次能确定一个数在序列中的最终位置。若发生逆序，则交换；有俩种方式进行冒泡，一种是先把小的冒泡到前边去，另一种是把大的元素冒泡到后边。

趣味解释：

有一群泡泡，其中一个泡泡跑到一个泡小妹说，小妹小妹你过来咱俩比比谁大，小妹说哇你好大，于是他跑到了泡小妹前面，又跟前面的一个泡大哥说，大哥，咱俩比比谁大呗。泡大哥看了他一眼他就老实了。这就是内层的for，那个泡泡跟每个人都比一次。

话说那个泡泡刚老实下来，另一个泡泡又开始跟别人比谁大了，这就是外层的for，每个泡泡都会做一次跟其他泡泡比个没完的事。

#### 2.2 实现逻辑

- 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
- 针对所有的元素重复以上的步骤，除了最后一个。
- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

通过两层循环控制：

- 第一个循环（外循环），负责把需要冒泡的那个数字排除在外；
- 第二个循环（内循环），负责两两比较交换。

#### 2.3 动图演示bubble_sort

![v2-33a947c71ad62b254cab62e5364d2813_b](D:\markdown file\截图\v2-33a947c71ad62b254cab62e5364d2813_b.gif)

#### 2.4 性能分析

- 平均时间复杂度：O(N^2)
- 最佳时间复杂度：O(N)
- 最差时间复杂度：O(N^2)
- 空间复杂度：O(1)
- 排序方式：In-place
- 稳定性：稳定

解析说明：

冒泡排序涉及相邻两两数据的比较，故需要嵌套两层 for 循环来控制;

外层循环 n 次，内层最多时循环 n – 1次、最少循环 0 次，平均循环(n-1)/2;

所以循环体内总的比较交换次数为：n*(n-1) / 2 = (n^2-n)/2 ;

按照计算时间复杂度的规则，去掉常数、去掉最高项系数，其复杂度为O(N^2) ;

最优的空间复杂度为开始元素已排序，则空间复杂度为 0;

最差的空间复杂度为开始元素为逆排序，则空间复杂度为 O(N);

平均的空间复杂度为O(1) .

注：

> n：数据规模
> k：”桶”的个数
> In-place：占用常数内存，不占用额外内存
> Out-place：占用额外内存

#### 2.5 代码实现

```java
// 冒泡排序（Java）
public static void bubbleSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    // 0 ~ N-1
    // 0 ~ N-2
    // 0 ~ N-3
    for (int e = arr.length - 1; e > 0; e--) { // 0 ~ e
        for (int i = 0; i < e; i++) {
            if (arr[i] > arr[i + 1]) {
                swap(arr, i, i + 1);
            }
        }
    }
}
```

#### 2.6 优化改进

##### 2.6.1 改进方法①

场景一：

在某次遍历中如果没有数据交换，说明整个数组已经有序。若初始序列就是排序好的，如果用基础的冒泡排序方法，仍然还要比较O(N^2)次，但无交换次数。

改进思路：

通过设置标志位来记录此次遍历有无数据交换，进而可以判断是否要继续循环，设置一个flag标记，当在一趟序列中没有发生交换，则该序列已排序好，但优化后排序的时间复杂度没有发生量级的改变。

改进代码：

```cpp
// 冒泡排序改进(C++)
void bubble_sort(int arr[], int len)
{
    for (int i = 0; i < len-1; i++){        //比较n-1次
        bool exchange = true;               //冒泡的改进，若在一趟中没有发生逆序，则该序列已有序
        for (int j = len-1; j >i; j--){     //每次从后边冒出一个最小值
            if (arr[j] < arr[j - 1]){       //发生逆序，则交换
                swap(arr[j], arr[j - 1]);
                exchange = false;
            }
        }
        if (exchange){
            return;
        }
    }
}
```

##### 2.6.2 改进方法②

场景二：

如果有100个数的数组，仅前面10个无序，后面90个都已排好序且都大于前面10个数字，那么在第一趟遍历后，最后发生交换的位置必定小于10，且这个位置之后的数据必定已经有序了。

改进思路：

记录某次遍历时最后发生数据交换的位置pos，这个位置之后的数据显然已经有序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。

改进代码：

```cpp
// 冒泡排序改进②
void bubble_sort(int arr[], int len)  
{  
    int j, k;  
    int flag;  
    flag = len;  
    while (flag > 0)  
    {  
        k = flag;  
        flag = 0;  
        for (j = 1; j < k; j++)  
            if (arr[j - 1] > arr[j])  
            {  
                swap(arr[j - 1], arr[j]);  
                flag = j;  
            }  
    }  
}
```

### 3. 插入排序（Insertion Sort）

*插入排序（Insertion-Sort）*的算法描述是一种简单直观的排序算法。打过扑克牌的应该都会明白（当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那我只能呵呵了）

#### 3.1 基本思想

插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

趣味解释：

![img](https://pic3.zhimg.com/80/v2-91dc753e1ddc5348eafd57ab24a8bab6_720w.webp)

插入排序操作类似于摸牌并将其从大到小排列。每次摸到一张牌后，根据其点数插入到确切位置。

如上图：表示的是摸到草花7后进行插入的过程。忽略最右边的草花10，相当于一开始7在最右边，然后逐个与左边的排相比较(当然左边的牌早已排好顺序)，将其放置在合适的位置。当摸到草花10后重复上述过程即可。

而实际中，如何将插入牌的这个过程应用到实际排序操作中呢？具体我们以一组数字来说操作说明：

![img](https://pic1.zhimg.com/v2-8de71a6d88ccc5754deb89d58bcc8800_r.jpg)

例如我们有一组数字：｛5，2，4，6，1，3｝，我们要将这组数字从小到大进行排列。 我们从第二个数字开始，将其认为是新增加的数字，这样第二个数字只需与其左边的第一个数字比较后排好序；在第三个数字，认为前两个已经排好序的数字为手里整理好的牌，那么只需将第三个数字与前两个数字比较即可；以此类推，直到最后一个数字与前面的所有数字比较结束，插入排序完成。

#### 3.2 实现逻辑

> ① 从第一个元素开始，该元素可以认为已经被排序
> ② 取出下一个元素，在已经排序的元素序列中从后向前扫描
> ③如果该元素（已排序）大于新元素，将该元素移到下一位置
> ④ 重复步骤③，直到找到已排序的元素小于或者等于新元素的位置
> ⑤将新元素插入到该位置后
> ⑥ 重复步骤②~⑤

#### 3.3 动图演示

![v2-91b76e8e4dab9b0cad9a017d7dd431e2_b](D:\markdown file\截图\v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.gif)

#### 3.4 性能分析

> 平均时间复杂度：O(N^2)
> 最差时间复杂度：O(N^2)
> 空间复杂度：O(1)
> 排序方式：In-place
> 稳定性：稳定

如果插入排序的目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况：

> (1) 最好情况：序列已经是升序排列，在这种情况下，需要进行的比较操作需(n-1)次即可。
> (2) 最坏情况：序列是降序排列，那么此时需要进行的比较共有n(n-1)/2次。

插入排序的赋值操作是比较操作的次数减去(n-1)次。平均来说插入排序算法复杂度为O(N^2)。

最优的空间复杂度为开始元素已排序，则空间复杂度为 0；

最差的空间复杂度为开始元素为逆排序，则空间复杂度最坏时为 O(N);

平均的空间复杂度为O(1)

```text
注：
n：数据规模
k：”桶”的个数
In-place：占用常数内存，不占用额外内存
Out-place：占用额外内存
```

#### 3.5 代码实现

```cpp
public static void insertionSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    // 不只1个数
    for (int end = 1; end < arr.length; end++) { // 0 ~ end 做到有序
        for (int pre = end - 1; pre >= 0 && arr[pre] > arr[pre + 1]; pre--) {
            swap(arr, pre, pre + 1);
        }
    }
}
```

#### 3.6 算法优化改进

##### 3.6.1 改进方法①

场景分析：

直接插入排序每次往前插入时，是按顺序依次往前查找，数据量较大时，必然比较耗时，效率低。

改进思路： 在往前找合适的插入位置时采用二分查找的方式，即折半插入。

二分插入排序相对直接插入排序而言：平均性能更快，时间复杂度降至O(NlogN)，排序是稳定的，但排序的比较次数与初始序列无关，相比直接插入排序，在速度上有一定提升。逻辑步骤：

> ① 从第一个元素开始，该元素可以认为已经被排序
> ② 取出下一个元素，在已经排序的元素序列中二分查找到第一个比它大的数的位置
> ③将新元素插入到该位置后
> ④ 重复上述两步

改进代码：

```cpp
// 插入排序改进：二分插入排序
void BinaryInsertSort(int arr[], int len)   
{   
    int key, left, right, middle;   
    for (int i=1; i<len; i++)   
    {   
        key = a[i];   
        left = 0;   
        right = i-1;   
        while (left<=right)   
        {   
            middle = (left+right)/2;   
            if (a[middle]>key)   
                right = middle-1;   
            else   
                left = middle+1;   
        }   

        for(int j=i-1; j>=left; j--)   
        {   
            a[j+1] = a[j];   
        }   

        a[left] = key;          
    }   
}
```

##### 3.6.2 改进方法②

场景分析：

(1) 插入排序对几乎已排好序的数据操作时，效率很高，可以达到线性排序的效率。

(2) 插入排序在每次往前插入时只能将数据移动一位，效率比较低。

改进思路：

先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。

改进思路二的方法实际上就是希尔排序。在这里只给出思路，在后续系列《算法：排序算法之希尔排序》中再做具体讲解说明。





